#pragma once
//深度优先搜素
/*
思考：
假如有编号为1~3的3张扑克牌和编号为1~3的3个盒子，现在需要将3张牌分别放到3个盒子中去，且每个盒子只能放一张牌，一共有多少种不同的放法。

当走到一个盒子面前的时候，到底要放那一张牌呢？在这里应该把所有的牌都尝试一遍。
假设这里约定一个顺序，按牌面值从小到大依次尝试。在这样的假定下，当走到第一个盒子的时候，放入1号牌。
放好之后，继续向后走，走到第二个盒子面前，此时还剩2张牌，牌面值最小的为2号牌，按照约定的规则，把2号牌放入第二个盒子。
此时，来到第三个盒子面前，只剩一张牌，放入第三个盒子。此时手中的牌已经用完。
继续向后走，走到了盒子的尽头，后面再也没有盒子，并且也没有可用的牌了，此时，一种放法已经完成了，
但是这只是一种放法，这条路已经走到了尽头，还需要折返，重新回到上一个盒子。
这里回到第三个盒子，把第三个盒子中的牌取出来，再去尝试能否再放其它的牌，这时候手里仍然只有一张3号
牌，没有别的选择了，所以还需要继续向后回退，回到2号盒子面前。
收回2号盒子中的2号牌，现在手里有两张牌，2，3，按照约定，再把3号牌放入2号盒子，放好之后，继续向后走，来到3号盒子。
此时手里只有一张2号牌，把它放入3号盒子，继续向后走。
此时这条路又一次走到了尽头，一个新的放法又产生了，继续向上折返，尝试其它可能，按照上述步骤，依次会产生所有结果。

深度优先搜索的关键是解决"当下该如何做"，下一步的做法和当下的做法是一样的。
"当下如何做"一般是尝试每一种可能，用for循环遍历，对于每一种可能确定之后，继续走下一步;
当前的剩余可能等到从下一步回退之后再处理。
深度优先搜索的模型：
Dfs(当前这一步的处理逻辑)
{
	1. 判断边界，是否已经一条道走到黑了：向上回退
	2. 尝试当下的每一种可能
	3. 确定一种可能之后，继续下一步 Dfs(下一步)
}
*/