#pragma once
/*
哈希表：元素不是按照空间连续存放的，数据的存放位置都是按照相同的规则计算得到
1.计算规则：
哈希函数：通过数据得到数据在容器中的位置。
常用的哈希函数：
(1)直接定址法：可以认为线性函数：A*x+B------>只适合用于范围确定且范围比较小的数据
eg：统计26个小写字母出现的次数。
解决方式：建立一个大小为26的数组，通过array[ch-'a']++，哈希函数：A:1，x:ch，B:-'a'
(2)除留余数法(通用的)：取模运算---->数据%数组的大小
2.哈希冲突：不同的数据通过规则计算得到的存放位置相同
(1)缓解哈希冲突：
a.选择合适的哈希函数。
b.负载量：可以用负载因子衡量：元素个数/数组大小，一般负载因子控制在0.7左右。
负载量越小，造成冲突的可能性就越小，即负载因子越小，冲突就越小。
(2)解决哈希冲突
a.闭散列：
线性探测：从发生冲突的位置开始，向后遍历，找到第一个空的位置，存放元素。
二次探测：
b.开散列：
哈希桶/拉链法：
1.可以通俗理解为一个单链表数组
哈希表中每个位置挂一个单链表，表中每个位置实际存放的为单链表的头结点
发生哈希冲突的元素会挂在同一个单链表中，不会影响其他元素的哈希位置
如果单链表中的元素个数大于指定的阈值，一般会考虑挂红黑树。
2.性能：
最好是O(1)，最坏也是一个O(logN)
3.迭代器：
方向：通过节点实现迭代器
begin：第一个非空链表的头结点
end：空结点
前置++：
(1)如果当前节点的next不为空，++会走到next节点
(2)如果当前节点的next为空，++找到下一个非空链表的头节点
借助哈希表的位置找到下一个非空链表的头节点
3.元素查找：
首先计算位置，从计算的位置开始查找元素，直到遇到空的位置，结束查找。
4.元素删除：
伪删除，通过状态标记已经删除的数据，不能直接删除，如果直接删除，会导致某些数据找不到
*/
